{
  "fileName": "regexPluginResearch",
  "dir": ".pd/regexPluginResearch",
  "config": {
    "on": {},
    "emit": true,
    "persist": true,
    "exclude": [
      "node_modules",
      "dist",
      "build",
      "coverage",
      "public",
      "temp",
      "docs",
      "_site"
    ]
  },
  "name": "Wikilink Plugin research",
  "camelName": "wikilinkPluginResearch",
  "steps": [
    {
      "name": "emitStartEvent",
      "code": "const event = new CustomEvent('pd:pipe:start', {detail: {input, opts}})\n          dispatchEvent(event)",
      "funcName": "emitStartEvent",
      "inList": false,
      "range": [
        0,
        0
      ],
      "internal": true
    },
    {
      "name": "persistInput",
      "code": "\n      const kvAvailable = typeof Deno !== 'undefined' && typeof Deno.openKv === 'function'\n      if(kvAvailable) {\n        try {\n          const db = await Deno.openKv()\n          const key = ['pd', 'input', opts.fileName]\n          try {\n              await db.set(key, JSON.stringify(input))\n          } catch (e) {\n            const safe = {\n              error: e.message,\n            }\n            for (const [k, v] of Object.entries(input)) {\n                safe[k] = typeof v;\n            }\n            await db.set(key, safe)\n          }\n        } catch (e) {\n            console.error(e)\n        }\n      } else {\n        const key = 'pd:input:' + opts.fileName \n        const inputJson = localStorage.getItem(key) || '[]'\n        const storedJson = JSON.parse(inputJson)\n        storedJson.push(JSON.stringify(input))\n        localStorage.setItem(key, JSON.stringify(storedJson))\n      }\n      ",
      "funcName": "persistInput",
      "inList": false,
      "range": [
        0,
        0
      ],
      "internal": true
    },
    {
      "code": "import markdownit from \"npm:markdown-it\";\nimport { walkSync } from \"jsr:@std/fs\";\nimport { relative } from \"jsr:@std/path\";\n",
      "range": [
        34,
        36
      ],
      "name": "Wikilink Plugin research",
      "funcName": "wikilinkPluginResearch",
      "inList": false
    },
    {
      "code": "const md = markdownit().use((md, options) => {\n    md.inline.ruler.push('wikimatch', (state, silent) => {\n        // thanks copilot? ðŸ‘‡\n        // state.src = state.src.replace(/\\[\\[(.*?)\\]\\]/g, (match, content) => {\n        //     return `<a href=\"/${content}\">${content}</a>`\n        // })\n\n        const match = /^\\[\\[(.*)\\]\\]/.exec(state.src.slice(state.pos))\n        if(!match) {\n            console.log('no match',state.src.slice(state.pos))\n            return;\n        }\n        // let the parser skip what we've matched\n        state.pos += match[0].length\n\n        if (silent) return true\n        const token = state.push('wikimatch', '', 0)\n        token.meta = {match}\n        return true;\n    })\n    md.renderer.rules.wikimatch = (tokens, idx) => {\n        let firstFile: FileInfo | undefined;\n        try {\n            for (const file of walkSync(Deno.cwd(), { skip: [/\\.pd/, /_site/]})) {\n                if (file.path.includes(tokens[idx].meta.match[1])) {\n                    firstFile = file;\n                    break;\n                }\n            }\n        } catch (e) {\n            // wont work in the browser\n            console.error(e)\n        }\n\n        const path = firstFile ? relative(Deno.cwd(), firstFile.path) : tokens[idx].meta.match[1];\n\n        console.log({firstFile})\n        return `<a href=\"/${path}\">${path}</a>`\n    }\n})\n\n$p.set(input, '/markdown.dirtyInlinePlugin', md.render(`# hello\n\nhow about now\n\n[wat](/wat)\n\n[[evalPipedown]]`))\n",
      "range": [
        48,
        50
      ],
      "name": "start simple",
      "funcName": "startSimple",
      "inList": false
    },
    {
      "name": "persistOutput",
      "code": "\n      const kvAvailable = typeof Deno !== 'undefined' && typeof Deno.openKv === 'function'\n      if(kvAvailable) {\n        try {\n          const db = await Deno.openKv()\n          const key = ['pd', 'output', opts.fileName]\n          try {\n              await db.set(key, JSON.stringify(input))\n          } catch (e) {\n            const safe = {\n              error: e.message,\n            }\n            for (const [k, v] of Object.entries(input)) {\n                safe[k] = typeof v;\n            }\n            await db.set(key, safe)\n          }\n        } catch (e) {\n            console.error(e)\n        }\n      } else {\n        const key = 'pd:output:' + opts.fileName \n        const inputJson = localStorage.getItem(key) || '[]'\n        const storedJson = JSON.parse(inputJson)\n        storedJson.push(JSON.stringify(input))\n        localStorage.setItem(key, JSON.stringify(storedJson))\n      }\n      ",
      "funcName": "persistOutput",
      "inList": false,
      "range": [
        0,
        0
      ],
      "internal": true
    },
    {
      "name": "emitEndEvent",
      "code": "const event = new CustomEvent('pd:pipe:end', {detail: {input, opts}})\n          dispatchEvent(event)",
      "funcName": "emitEndEvent",
      "inList": false,
      "range": [
        0,
        0
      ],
      "internal": true
    }
  ]
}